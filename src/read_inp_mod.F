      module read_inp_mod

      use param, only: mynode, nnodes, ocean_grid_comm
      use mpi_f08, only: mpi_byte
      use roms_read_write, only: git_hash
      use keyword_registry, only:
     &     init_registry, registry, register_keyword,
     &     report_keyword_mismatch, lookup_keyword
      use error_handling_mod, only: error_log
      implicit none
      character(len=12) :: module_name = "read_inp_mod"
      character(len=1024) :: error_info = ""
      integer :: testunit = 40
      contains

#include "cppdefs.opt"

      subroutine register_keywords
!-----------------------------------------------------------------------
!     SUBROUTINE: register_keywords
!     DESCRIPTION:
!     Register all legal input file keywords and associated handlers.
!
!     Populates the keyword registry with all input file kewords
!     supported by this build and binds each one to a handler routine.
!     Handler routines are defined in their own section at the end of
!     this module.
!-----------------------------------------------------------------------

      implicit none

         call register_keyword(name="title",handler=kwread_title)
         call register_keyword(name="time_stepping",handler=kwread_time_stepping)
#ifdef MARBL
         call register_keyword(name="MARBL_biogeochemistry",handler=kwread_marbl_bgc)
#endif
#ifdef SOLVE3D
         call register_keyword(name="S-coord",handler=kwread_scoord)
         call register_keyword(name="rho0",handler=kwread_rho0)
#endif
#ifndef NONLIN_EOS
         call register_keyword(name="lin_rho_eos",handler=kwread_lin_rho_eos)
#endif
#ifdef UV_VIS2
         call register_keyword(name="lateral_visc",handler=kwread_lateral_visc)
#if !defined EW_PERIODIC || !defined NS_PERIODIC
         call register_keyword(name="gamma2",handler=kwread_gamma2)
#endif
#endif
#ifdef TS_DIF2
         call register_keyword(name="tracer_diff2",handler=kwread_tracer_diff2)
#endif
         call register_keyword(name="bottom_drag",handler=kwread_bottom_drag)

#ifdef SOLVE3D
!#if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
!         &&                     !defined MY2_MIXING && !defined MY25_MIXING

         call register_keyword(name="vertical_mixing",
     &        required=.false., handler=kwread_vertical_mixing)
!#endif
#ifdef MY25_MIXING
         call register_keyword(name="MY_bak_mixing",handler=kwread_my_bak_mixing)
#endif
#if defined SFLX_CORR && defined SALINITY
         call register_keyword(name="SSS_correction",handler=kwread_sss_correction)
#endif
#ifdef QCORRECTION
         call register_keyword(name="SST_correction",handler=kwread_sst_correction)
#endif
#endif /* SOLVE3D */

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY
         call register_keyword(name="ubind",handler=kwread_ubind)
#endif
#ifdef SPONGE
         call register_keyword(name="v_sponge",handler=kwread_v_sponge)
#endif
#ifndef ANA_GRID
         call register_keyword(name="grid",handler=kwread_grid)
#endif
         call register_keyword(name="initial",handler=kwread_initial)
         call register_keyword(name="forcing",handler=kwread_forcing)
#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
                        defined T_FRC_BRY )) && !defined ANA_TCLIMA
         call register_keyword(name="climatology",handler=kwread_climatology)
#endif
         call register_keyword(name="output_root_name",handler=kwread_output_root_name)

      end subroutine register_keywords

      subroutine check_setup()
!-----------------------------------------------------------------------
!     SUBROUTINE: check_setup
!     DESCRIPTION:
!     Call any subroutines used to check the current configuration.
!
!     Check CPP-switches for consistency. This operation is split into
!     multiple stages because the first subroutine, "check_switches1", is
!     generated by special program cppcheck (file cppcheck.F) by examining
!     and documention all CPP-switches appearing in "cppdefs.opt" regardless
!     of their context, and automatically generate a code to keep track of
!     their status, as well as to traps multiply defined global
!     configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
!     etc).  The subsequent routines are to track locally-defined switches
!     in few other places throughout the code (these routines are
!     hand-written), and, finally, the last routine, "check_switches2"
!     contains traps for mutually exclussive definitions of non-project
!     switches (e.g. it traps multiply defined vertical mixing schemes or
!     lateral boundary conditions; this code is also hand written).
!-----------------------------------------------------------------------

         implicit none

         call check_tiling()
         call check_switches1()
#ifdef SOLVE3D
         call check_pre_step_switches()
         call check_step_uv1_switches()
         call check_step_uv2_switches()
         call check_step_t_switches()
         call check_set_HUV1_switches()
# ifdef LMD_KPP
         call check_kpp_switches()
# endif
         call check_switches2()
#endif
      end subroutine check_setup

      subroutine read_inp()
!-----------------------------------------------------------------------
!     SUBROUTINE: read_inp
!     DESCRIPTION:
!     Read the ROMS runtime input file and set runtime parameters
!
!     METHOD:
!     1. A series of configuration-based checks and prints are made
!     2. The input file keyword registry is established via a call to
!     register_keywords
!     3. The specific input file for this run is opened and verified
!     against the registry
!     4. A second pass of the input file determines line-by-line the
!     relevant keyword (via a call to extract_keyword) and then defers
!     to the registered handler to parse the settings from that section.
!-----------------------------------------------------------------------


      implicit none
      integer  ios, idx, ierr
      integer, parameter :: input=15,
     &                  max_fname=256, max_kwsize=256
      character(len=max_fname)  :: fname, force_string
      character(len=max_kwsize) :: keyword
      character(len=3), parameter :: end_signal='end'
      integer is,ie,  kwlen
#ifdef SOLVE3D
     &                                 , itrc
#endif
#ifdef INT_IARGC
      integer iargc
#endif
      logical :: eof = .false.
      character(len=8) :: sr_name = "read_inp"

      ! Configuration checks
      call check_setup()

      ! Print relevant information
      mpi_master_only call print_switches
!     Git hash
      mpi_master_only write(*,'(/1x,2A)') "Git hash: ", git_hash
      call print_jobid

      ! Set default input settings filename:
      fname='roms.in'
#ifdef MPI
      if (mynode == 0) then
#endif
        is=iargc() ; if (is == 1) call getarg(is,fname)
#ifdef MPI
      endif
      call MPI_Bcast(fname,max_fname,MPI_BYTE, 0, ocean_grid_comm, ierr)
#endif

! Setup keyword registry and check input file against registry
      call init_registry()
      call register_keywords()
      call check_input_file_keywords(fname)

!     Open input file to read keywords
      open(input, file=fname, status='old', form='formatted', iostat=ios)
      if (ios /= 0) then
         call report_opening_error(trim(fname))
         return
      end if

! Read keywords in loop over lines
      do while (.not. eof)
         call extract_keyword(input, keyword, kwlen, eof)
         if (eof) exit
         if (kwlen == 0) cycle  ! no keyword on this line â†’ read next
         if (keyword(1:kwlen) == end_signal) exit
         idx = lookup_keyword(keyword)
         if (idx==0) then
            mpi_master_only write(*,
     &           '("WARNING: unregistered keyword encountered: ",A)') trim(keyword)
            cycle
         end if
         if (associated(registry(idx)%handler)) then
            call registry(idx)%handler(input)
         else
            write(error_info,*) "No handler registered for keyword ", trim(keyword)
            return
         end if
      end do
      close (input)
      call error_log%abort_check()
!     call check_srcs
      end subroutine read_inp

      subroutine check_input_file_keywords(fname)
!-----------------------------------------------------------------------
!     SUBROUTINE: check_input_file_keywords
!     DESCRIPTION:
!     Perform a first-pass check of the provided input file's keywords
!     against the keyword registry, highlighting any mismatches.
!-----------------------------------------------------------------------
      implicit none

      character(len=*), intent(in) :: fname
      integer :: unit, ios, kwlen, idx
      character(len=256) :: keyword
      logical :: eof

      open(newunit=unit, file=fname, status='old', action='read', iostat=ios)
      if (ios /= 0) then
         call report_opening_error(trim(fname))
         return
      end if

      eof = .false.
      do while(.not.eof)
         call extract_keyword(unit, keyword, kwlen, eof)
         if (eof) exit
         if (kwlen == 0) cycle
         if (keyword == "end") exit

         idx = lookup_keyword(keyword)
         if (idx > 0) then
            registry(idx)%found = registry(idx)%found + 1
         else
            mpi_master_only write(*,
     &           '("WARNING: unregistered keyword encountered: ",A)') trim(keyword)
         end if
      end do

      close(unit)

      call report_keyword_mismatch()
      end subroutine check_input_file_keywords

      subroutine report_opening_error(fname)
!-----------------------------------------------------------------------
!     SUBROUTINE: report_opening_error
!     DESCRIPTION:
!     subroutine to report an error when opening the input file
!-----------------------------------------------------------------------

      implicit none
      character(len=*), intent(in) :: fname

      error_info = "Cannot find input file '" // trim(fname) // "'"
      call error_log%raise_from_rank(
     &     info=error_info,
     &     context=module_name)

      end subroutine report_opening_error

      subroutine report_read_error(keyword)
!-----------------------------------------------------------------------
!     SUBROUTINE: report_read_error
!     DESCRIPTION:
!     subroutine to report an error when reading the input file
!-----------------------------------------------------------------------
      implicit none
      character(len=*), intent(in) :: keyword

      error_info = "Cannot read entry '" // trim(keyword) // "'"
      call error_log%raise_global(
     &     info=error_info,
     &     context=module_name)

      end subroutine report_read_error

      subroutine extract_keyword(unit, keyword, kwlen, eof)
!-----------------------------------------------------------------------
!     SUBROUTINE: extract_keyword
!     DESCRIPTION:
!     Finds the next keyword (or EOF) in the runtime input settings file
!
!     Advances through the runtime input settings file until finding its
!     end or a valid keyword, and sets the corresponding output value of
!     `keyword` (char) or `eof` (logical).
!-----------------------------------------------------------------------

         implicit none
         integer, intent(in) :: unit
         character(len=*), intent(out) :: keyword
         integer, intent(out) :: kwlen
         logical, intent(out) :: eof

         character(len=256) :: line
         integer :: ios, start, colon_pos, lenline
         character(len=:), allocatable :: tmp

         eof = .false.
         keyword = ''
         kwlen = 0

         ! read next non-comment line
         do
            read(unit,'(A)',iostat=ios) line
            if (ios < 0) then
               eof = .true.
               return
            else if (ios /= 0) then
               return
            end if
            if (trim(line) /= '' .and. line(1:1) /= '!') exit
         end do

         lenline = len_trim(line)
         if (lenline == 0) return

         start = 1
         do while (start <= lenline .and. line(start:start) == ' ')
            start = start + 1
         end do
         if (start > lenline) return

         colon_pos = index(line(start:lenline), ':')
         if (colon_pos == 0) return
         colon_pos = colon_pos + start - 1

         tmp = adjustl(line(start:colon_pos-1))
         keyword = tmp
         kwlen   = len_trim(tmp)

      end subroutine extract_keyword

      subroutine print_jobid()
!-----------------------------------------------------------------------
!     SUBROUTINE: print_jobid()
!     DESCRIPTION:
!     Print SLURM or PBS job ID information (master-only write).
!
!     Retrieves and prints the job ID and, if applicable, the array task
!     index for SLURM or PBS/Torque jobs.
!-----------------------------------------------------------------------


      implicit none

      character(len=100) :: jobid, taskid
      integer            :: len1, len2, stat1, stat2

! --- SLURM ---
      call get_environment_variable('SLURM_JOB_ID', jobid, len1, stat1)
      call get_environment_variable('SLURM_ARRAY_TASK_ID', taskid, len2, stat2)

      if (stat1 == 0) then
         mpi_master_only write(*,'(A,1X,A)') 'SLURM Job ID:',        trim(jobid(1:len1))
         if (stat2 == 0) then
            mpi_master_only write(*,'(A,1X,A)') 'SLURM Array Task ID:', trim(taskid(1:len2))
         end if
         return
      end if
! --- PBS ---
      call get_environment_variable('PBS_JOBID', jobid, len1, stat1)
      call get_environment_variable('PBS_ARRAY_INDEX', taskid, len2, stat2)

      if (stat1 == 0) then
         mpi_master_only write(*,'(A,1X,A)') 'PBS Job ID:',          trim(jobid(1:len1))
          if (stat2 == 0) then
             mpi_master_only write(*,'(A,1X,A)') 'PBS Array Index:',  trim(taskid(1:len2))
          end if
          return
      end if
         mpi_master_only write(*,'(A)') 'No SLURM or PBS job ID found.'
      end subroutine print_jobid


!***********************************************************************
!     KEYWORD HANDLER ROUTINES
!     The below subroutines are used to parse runtime settings from the
!     input file, with each subroutine handling a specific keyword.
!     These handlers are bound to keywords in the registry at compile
!     time via a call to `register_keyword`.
!***********************************************************************

      subroutine kwread_title(unit)
      use roms_read_write, only: title
      implicit none
         integer, intent(in) :: unit
         integer ios

         read(unit,'(A)',iostat=ios) title
         if (ios /= 0) then
            call report_read_error("title")
            return
         end if
         mpi_master_only write(*,'(/1x,A)') trim(title)
      end subroutine

      subroutine kwread_time_stepping(unit)
      use scalars, only: dt, dtfast, ndtfast, ntimes, ninfo
      implicit none

      integer, intent(in) :: unit

      integer :: ios

! Read ntimes, dt, ndtfast, ninfo
      read(unit, *, iostat=ios) ntimes, dt, ndtfast, ninfo
      if (ios /= 0) then
         call report_read_error("time_stepping")
         return
      end if

      mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.

#ifndef SOLVE3D
      dt     = dtfast
      ntimes = ntimes * ndtfast
      ninfo  = ninfo  * ndtfast
#endif

      end subroutine kwread_time_stepping

#ifdef MARBL
      subroutine kwread_marbl_bgc(unit)
      use marbl_driver, only: marbl_namelist_fname, marbl_tracer_list_fname
#ifdef MARBL_DIAGS
      use marbl_driver, only: marbl_diag_list_fname
#endif
      implicit none

      integer, intent(in) :: unit
      integer :: ios, lstr, lenstr

! ---------------------------------------------------------
! Read MARBL namelist file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_namelist_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry")
         return
      end if
      lstr = lenstr(marbl_namelist_fname)
      mpi_master_only write(*,'(1x,A,15x,A)')
     &     'MARBL namelist file',marbl_namelist_fname(1:lstr)

! ---------------------------------------------------------
! Read tracer list file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_tracer_list_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry")
         return
      end if
      lstr = lenstr(marbl_tracer_list_fname)
      mpi_master_only write(*,'(1x,A,5x,A)')
     &     'MARBL tracer output list file',marbl_tracer_list_fname(1:lstr)

#ifdef MARBL_DIAGS
! ---------------------------------------------------------
! Read diagnostics list file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_diag_list_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry")
         return
      end if
      lstr = lenstr(marbl_diag_list_fname)
      mpi_master_only write(*,'(1x,A,1x,A)')
     &     'MARBL diagnostic output list file',marbl_diag_list_fname(1:lstr)
#endif

      end subroutine kwread_marbl_bgc
#endif

#ifdef SOLVE3D
      subroutine kwread_scoord(unit)
!     Vertical S-coordinates transformation. Note that "hc" may be chosen
!     to be very large (infinity) if vertically uniform sigma is desired.
      use scoord, only: hc, theta_b, theta_s
      implicit none

      integer, intent(in) :: unit
      integer :: ios

! Read three S-coordinate parameters
      read(unit, *, iostat=ios) theta_s, theta_b, hc
      if (ios /= 0) then
         call report_read_error("S-coord")
         return
      end if

          mpi_master_only write(*,'(2(/4x,A,F10.7,2x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc < 1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

      end subroutine kwread_scoord

      subroutine kwread_rho0(unit)
!--> Boussinesq  reference density.
      use scalars, only: rho0
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

! Read rho0 (Boussinesq reference density)
      read(unit, *, iostat=ios) rho0
      if (ios /= 0) then
         call report_read_error("rho0")
         return
      end if

      mpi_master_only write(*,'(7x,A,F10.4,2x,A)')  'rho0 =',
     &     rho0, 'Boussinesq reference density [kg/m^3].'

      end subroutine kwread_rho0
# ifndef NONLIN_EOS
      subroutine kwread_lin_rho_eos(unit)
      use eos_vars, only: Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif

      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
      if (ios /= 0) then
         call report_read_error('lin_rho_eos')
         return
      end if

      mpi_master_only write(*,'(4(6x,A,F10.4,2x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif

      end subroutine kwread_lin_rho_eos
# endif

#endif /*SOLVE3D*/
#ifdef UV_VIS2
      subroutine kwread_lateral_visc(unit)
!     Lateral viscosity coefficients.
      use scalars, only: visc2
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) visc2
      if (ios /= 0) then
         call report_read_error('lateral_visc')
         return
      end if

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'visc2 =', visc2,
     &    'horizontal Laplacian kinematic viscosity [m^2/s]'

      end subroutine kwread_lateral_visc

#if !defined EW_PERIODIC || !defined NS_PERIODIC
      subroutine kwread_gamma2(unit)
!     Lateral boundary slipperness.
      use scalars, only: gamma2
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) gamma2
      if (ios /= 0) then
         call report_read_error('gamma2')
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)')
     &    'gamma2 =', gamma2,
     &    'slipperiness parameter: ',
     &    'free-slip = +1, or no-slip = -1.'

      end subroutine kwread_gamma2
#endif
#endif

#if defined SOLVE3D && defined TS_DIF2
      subroutine kwread_tracer_diff2(unit)
      use scalars, only: nt, tnu2
      use param, only: itemp
      implicit none

      integer, intent(in)    :: unit
      integer :: ios, itrc

      read(unit,*,iostat=ios) (tnu2(itrc), itrc=1,NT)
      if (ios /= 0) then
         call report_read_error('tracer_diff2')
         return
      end if

      do itrc = 1, NT
         if (itrc == itemp) then
            mpi_master_only write(*,
     & '(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &    'tnu2(',itrc,') =', tnu2(itrc),
     &    'horizontal Laplacian ',
     &    'kinematic heat conductivity [m^2/s]'
         else
            mpi_master_only write(*,
     & '(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &    'tnu2(',itrc,') =', tnu2(itrc),
     &    'horizontal Laplacian ',
     &    'diffusion for tracer ', itrc, ', [m^2/s]'
         end if
      end do

      end subroutine kwread_tracer_diff2
#endif

      subroutine kwread_bottom_drag(unit)
      use scalars, only: rdrg, rdrg2, zob
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

#ifdef SOLVE3D
      read(unit,*,iostat=ios) rdrg, rdrg2, Zob
#else
      read(unit,*,iostat=ios) rdrg, rdrg2
#endif

      if (ios /= 0) then
         call report_read_error('bottom_drag')
         return
      end if

      mpi_master_only write(*,'(7x,A,ES10.3,2x,A)')
     &    'rdrg =', rdrg,
     &    'linear bottom drag coefficient [m/s]'

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'rdrg2 =', rdrg2,
     &    'quadratic bottom drag coefficient, nondim'

#ifdef SOLVE3D
      mpi_master_only write(*,'(8x,A,ES10.3,2x,A)')
     &    'Zob =', Zob,
     &    'bottom roughness height [m]'
#endif

      end subroutine kwread_bottom_drag

#ifdef SOLVE3D
!# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING \
!      &&                        !defined MY2_MIXING && !defined MY25_MIXING

      subroutine kwread_vertical_mixing(unit)
!     Background vertical viscosity and mixing coefficients for tracers.
      use scalars, only: akv_bak, akt_bak, nt
      implicit none

      integer, intent(in)    :: unit
      integer :: ios, itrc
      character(len=10) :: mixing_type



      read(unit,*,iostat=ios) Akv_bak, (Akt_bak(itrc), itrc=1,NT)
      if (ios /= 0) then
         call report_read_error('vertical_mixing')
         return
      end if

#if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING \
      &&                        !defined MY2_MIXING && !defined MY25_MIXING
      mixing_type = "background"
#else
      mixing_type = "additional"
#endif

      mpi_master_only write(*,'(4x,A,ES10.3,2x,2A)')
     &    'Akv_bak =', Akv_bak,
     &    mixing_type, ' vertical viscosity [m^2/s]'

      do itrc = 1, NT
         mpi_master_only write(*,'(1x,A,I1,A,ES10.3,2x,2A,I0)')
     &       'Akt_bak(', itrc, ') =', Akt_bak(itrc),
     &       mixing_type,' vertical mixing [m^2/s] for tracer #',
     &       itrc
      end do

      end subroutine kwread_vertical_mixing
!# endif

# ifdef MY25_MIXING
      subroutine kwread_MY_bak_mixing(unit)
!     Mellor-Yamada Level 2.5 turbulent closure parameters.
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) Akq_bak
#  ifdef Q_DIF2
     &                       , q2nu2
#  endif
#  ifdef Q_DIF4
     &                       , q2nu4
#  endif
      if (ios /= 0) then
         call report_read_error('MY_bak_mixing')
         return
      end if

      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'Akq_bak =', Akq_bak,
     &    'Background vertical mixing for TKE, [m^2/s]'

#  ifdef Q_DIF2
      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'q2nu2 =', q2nu2,
     &    'Horizontal Laplacian mixing for TKE, [m^2/s]'
#  endif

#  ifdef Q_DIF4
      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'q2nu4 =', q2nu4,
     &    'Horizontal biharmonic mixing for TKE, [m^4/s]'
#  endif

      end subroutine kwread_MY_bak_mixing
#endif

#if defined SFLX_CORR && defined SALINITY
      subroutine kwread_SSS_correction(unit)
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) dSSSdt
      if (ios /= 0) then
         call report_read_error('SSS_correction')
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSSdt =', dSSSdt,
     &   'Sea-Surface Salinity correction ',
     &   'coefficient expressed',
     &   'kinematically as "piston velocity" [cm/day]'

      dSSSdt = dSSSdt / (100*day2sec)

      end subroutine kwread_SSS_correction
#endif

# ifdef QCORRECTION
      subroutine kwread_SST_correction(unit)
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) dSSTdt
      if (ios /= 0) then
         call report_read_error('SST_correction')
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSTdt =', dSSTdt,
     &   'Sea-Surface Temperature correction ',
     &   'coefficient expressed',
     &   'kinematically as "piston velocity" [cm/day]'

      dSSTdt = dSSTdt / (100*day2sec)

      end subroutine kwread_SST_correction
# endif
#endif /*SOLVE3D*/

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
  || defined M3NUDGING  || defined WKB_FRC_BRY
      subroutine kwread_ubind(unit)
      use scalars, only: ubind
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) ubind
      if (ios /= 0) then
         call report_read_error('ubind')
         return
      end if

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'ubind =', ubind,
     &    'open boundary binding velcity [m/s]'

      end subroutine kwread_ubind
#endif

#ifdef SPONGE
      subroutine kwread_v_sponge(unit)
      use scalars, only: v_sponge
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,*,iostat=ios) v_sponge
      if (ios /= 0) then
         call report_read_error('v_sponge')
         return
      end if

      mpi_master_only write(*,'(3x,A,F10.2,2x,A)')
     &      'v_sponge =', v_sponge,
     &      'maximum viscosity in sponge layer [m^2/s]'

      end subroutine kwread_v_sponge
#endif

#ifndef ANA_GRID
      subroutine kwread_grid(unit)
      use roms_read_write, only: grdname
      implicit none

      integer, intent(in)    :: unit
      integer :: ios, lstr, lenstr
      character(len=256) :: fname

      read(unit,'(A)',iostat=ios) fname
      if (ios /= 0) then
         call report_read_error('grid')
         return
      end if

      lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
      call insert_node(fname, lstr, mynode, NNODES)
# endif
      open(newunit=testunit, file=trim(fname), status='old',
     &     iostat=ios)
      if (ios /= 0) then
         call report_opening_error(trim(fname))
         return
      end if
      close(testunit)

      grdname = trim(fname)
      mpi_master_only write(*,'(1x,2A)')
     &      'grid file: ', trim(grdname)

      end subroutine kwread_grid
#endif /* !ANA_GRID */

      subroutine kwread_initial(unit)
!     Initial conditions file name. Check its availability (in the case
!     of analytical initial conditions and nrrec=0 initial conditions are
!     created internally and no file is needed).
      use roms_read_write, only: nrrec, ininame
      implicit none

      integer, intent(in)    :: unit
      integer :: ios, lstr, lenstr
      character(len=256) :: fname

      read(unit,*,iostat=ios) nrrec
      if (ios /= 0) then
         call report_read_error('initial')
         return
      end if

#ifdef ANA_INITIAL
      if (nrrec > 0) then
#endif
         read(unit,'(A)',iostat=ios) fname
         if (ios /= 0) then
            call report_read_error('initial')
            return
         end if

         lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
         call insert_node(fname, lstr, mynode, NNODES)
# endif
         open(newunit=testunit, file=trim(fname), status='old',
     &        iostat=ios)
         if (ios /= 0) then
            call report_opening_error(trim(fname))
            return
         end if
         close(testunit)
         ininame = trim(fname)
         mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &        'initial condition :: rec =', nrrec,
     &        'file = ''', trim(ininame), ''''

#ifdef ANA_INITIAL
      endif
#endif

      end subroutine kwread_initial

      subroutine kwread_forcing(unit)
      use roms_read_write, only:
     &     force_files, force_info, max_frc_files,
     &     store_string_att, frcfile, max_frc
      implicit none

      integer, intent(in)    :: unit

      integer :: ios, lstr, lenstr
      character(len=256) :: fname
      character(len=15) :: sr_name = "kwread_forcing"

!  Reset forcing storage.

      force_files = ''
      force_info  = ''
      max_frc     = 0
      lstr        = 1

!  Read filenames until a blank line or max_frc_files reached.
      do while (lstr > 0 .and. max_frc < max_frc_files+1)

         read(unit,'(A)',iostat=ios) fname
         if (ios /= 0) then
            call report_read_error('forcing')
            return
         end if

         lstr = lenstr(fname)

         if (lstr > 0) then

# if defined MPI && defined PARALLEL_FILES
            call insert_node(fname, lstr, mynode, NNODES)
# endif

! Test file availability

            open(newunit=testunit, file=trim(fname), status='old',
     &           iostat=ios)
            if (ios /= 0) then
               call report_opening_error(trim(fname))
               return
            end if
            close(testunit)

! Store file if within limit of allowed no. of forcing files

            if (max_frc < max_frc_files) then

               max_frc = max_frc + 1
               frcfile(max_frc) = trim(fname)

! Write file info to output stream
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_frc == 1) then
                    write(*,'(1x,2A)') 'forcing data file(s): ',
     &                                 trim(frcfile(max_frc))
                  else
                    write(*,'(23x,A)') trim(frcfile(max_frc))
                  endif
! Add to attributes
c$$$                  if (mynode == 0) then
c$$$                  end if TODO

# ifdef MPI_SILENT_MODE
               end if
# endif
               call store_string_att(force_files,
     &              frcfile(max_frc)(1:lstr))

            else !(if max_frc < max_frc_files )
               write(error_info,*)
     &              'Too many forcing files are ',
     &              'specified in input script.',  'Increase parameter ',
     &              '''max_frc_files'' in ',
     &              'roms_read_write and recompile.'
               call error_log%raise_global(
     &              info=error_info,
     &              context=module_name//"/"//sr_name)
            end if !(max_frc < max_frc_files)
         end if   ! lstr > 0
      end do      ! filename loop

      end subroutine kwread_forcing

#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
    defined T_FRC_BRY )) &&   !defined ANA_TCLIMA

      subroutine kwread_climatology(unit)
! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no
! climatology file is needed.  The following code segments also
! checks for availability of clm_file.

      implicit none

      integer, intent(in)    :: unit
      integer :: ios, lstr, lenstr
      character(len=256) :: fname

      read(unit,'(A)',iostat=ios) fname
      if (ios /= 0) then
         call report_read_error('climatology')
         return
      end if

      lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
      call insert_node(fname, lstr, mynode, NNODES)
# endif

      open(newunit=testunit, file=trim(fname), status='old',
     &     iostat=ios)
      if (ios /= 0) then
         call report_opening_error(trim(fname))
         return
      end if
      close(testunit)
      clm_file = trim(fname)
          mpi_master_only write(*,'(1x,4A)')   'climatology data :: ',
     &                           'file = ''', trim(clm_file), ''''

      end subroutine kwread_climatology
#endif

      subroutine kwread_output_root_name(unit)
      ! read from .in file the root-name
      ! for all output netcdf result files
      ! this is called from read_inp.F
      ! The following needs to be in the roms.in input file to use this
      ! subroutine (file name needs to be 5 spaces from left margin):
      !output_root_name:
      !     rootname (<- insert desired rootname)
      use roms_read_write, only: output_root_name
      implicit none

      integer, intent(in)    :: unit
      integer :: ios

      read(unit,'(A)',iostat=ios) output_root_name
      if (ios /= 0) then
         call report_read_error('output_root_name')
         return
      end if

      end subroutine kwread_output_root_name
      end module read_inp_mod
