      module read_inp_mod

      use param
      use surf_flux
      use boundary
      use eos_vars
      use basic_output
      use scalars
      use scoord
      use mpi
      use roms_read_write
#ifdef MARBL
      use marbl_driver, only: marbl_namelist_fname, marbl_tracer_list_fname
#ifdef MARBL_DIAGS
     &     , marbl_diag_list_fname
#endif
#endif
      use keyword_registry, only: init_registry, registry, register_keyword, report_keyword_mismatch, lookup_keyword

      implicit none
      contains

#include "cppdefs.opt"

                                        ! Read and report model input
      subroutine read_inp(ierr)         ! parameters from keyword-based
                                        ! startup file.

      implicit none
      integer ierr, ios, idx

      integer, parameter :: input=15, testunit=40,
     &                  max_fname=256, max_kwsize=256
      character(len=max_fname)  :: fname, force_string
      character(len=max_kwsize) :: keyword
      character(len=3), parameter :: end_signal='end'
      integer is,ie,  kwlen, lstr, lenstr
#ifdef SOLVE3D
     &                                 , itrc
#endif
#ifdef INT_IARGC
      integer iargc
#endif
      logical :: eof = .false.

! Check CPP-switches for consistency. This operation is split into
! multiple stages because the first subroutine, "check_switches1", is
! generated by special program cppcheck (file cppcheck.F) by examining
! and documention all CPP-switches appearing in "cppdefs.opt" regardless
! of their context, and automatically generate a code to keep track of
! their status, as well as to traps multiply defined global
! configurations (project switches, such as PACIFIC, USWEST, DAMEE_B,
! etc).  The subsequent routines are to track locally-defined switches
! in few other places throughout the code (these routines are
! hand-written), and, finally, the last routine, "check_switches2"
! contains traps for mutually exclussive definitions of non-project
! switches (e.g. it traps multiply defined vertical mixing schemes or
! lateral boundary conditions; this code is also hand written).
! All the checking routines codes are written in transparent mode:
! they assumed that error flag (ierr) is initialized at the entry and
! they add 1 for each error discovered.

      ierr=0                      ! <-- reset error counter
      call check_tiling(ierr)
      call check_switches1(ierr)
#ifdef SOLVE3D
      call check_pre_step_switches(ierr)
      call check_step_uv1_switches(ierr)
      call check_step_uv2_switches(ierr)
      call check_step_t_switches(ierr)
      call check_set_HUV1_switches(ierr)
# ifdef LMD_KPP
      call check_kpp_switches(ierr)
# endif
      call check_switches2(ierr)
#endif
      if (ierr /= 0) return
      mpi_master_only call print_switches
!     Git hash
      mpi_master_only write(*,'(/1x,2A)') "Git hash: ", git_hash
      call print_jobid

! Use pre-set default startup filename for known applications, or
! get it as an argument from command line via iargc-getarg (override
! default). NOTE: The usage of the executable should be either
!
!              roms
!        or
!              roms startup_file_name
!
! WITHOUT the UNIX redirection (<): roms < startup_file like it
! used to be.

      fname='roms.in'  !<-- default
#ifdef MPI
      if (mynode == 0) then
#endif
        is=iargc() ; if (is == 1) call getarg(is,fname)
#ifdef MPI
      endif
      call MPI_Bcast(fname,max_fname,MPI_BYTE, 0, ocean_grid_comm, ierr)
#endif

      call init_registry()

!––––– REGISTER ALL KEYWORDS EXPECTED IN THE FILE –––––
      call register_keyword(name="title",handler=read_title)
      call register_keyword(name="time_stepping",handler=read_time_stepping)
#ifdef MARBL
      call register_keyword(name="MARBL_biogeochemistry",handler=read_marbl_bgc)
#endif
#ifdef SOLVE3D
      call register_keyword(name="S-coord",handler=read_scoord)
      call register_keyword(name="rho0",handler=read_rho0)
#endif
#ifndef NONLIN_EOS
      call register_keyword(name="lin_rho_eos",handler=read_lin_rho_eos)
#endif
#ifdef UV_VIS2
      call register_keyword(name="lateral_visc",handler=read_lateral_visc)
#if !defined EW_PERIODIC || !defined NS_PERIODIC
      call register_keyword(name="gamma2",handler=read_gamma2)
#endif
#endif
#ifdef TS_DIF2
      call register_keyword(name="tracer_diff2",handler=read_tracer_diff2)
#endif
      call register_keyword(name="bottom_drag",handler=read_bottom_drag)

#ifdef SOLVE3D
#if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING\
                         && !defined MY2_MIXING && !defined MY25_MIXING
      call register_keyword(name="vertical_mixing",handler=read_vertical_mixing)
#endif
#ifdef MY25_MIXING
      call register_keyword(name="MY_bak_mixing",handler=read_my_bak_mixing)
#endif
#if defined SFLX_CORR && defined SALINITY
      call register_keyword(name="SSS_correction",handler=read_sss_correction)
#endif
#ifdef QCORRECTION
      call register_keyword(name="SST_correction",handler=read_sst_correction)
#endif
#endif /* SOLVE3D */

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
                       || defined M3NUDGING  || defined WKB_FRC_BRY
      call register_keyword(name="ubind",handler=read_ubind)
#endif
#ifdef SPONGE
      call register_keyword(name="v_sponge",handler=read_v_sponge)
#endif
#ifndef ANA_GRID
      call register_keyword(name="grid",handler=read_grid)
#endif
      call register_keyword(name="initial",handler=read_initial)
      call register_keyword(name="forcing",handler=read_forcing)
#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
                        defined T_FRC_BRY )) && !defined ANA_TCLIMA
      call register_keyword(name="climatology",handler=read_climatology)
#endif
      call register_keyword(name="output_root_name",handler=read_output_root_name)

!––––– FIRST PASS –––––
      call initial_keyword_check(fname, ierr)
      call report_keyword_mismatch(ierr)
      if (ierr /= 0) then
         write(*,'("CONFIGURATION ERRORS DETECTED IN FIRST PASS")')
         return
      end if


! Read in keyword name: keep trying, until keyword is found.
!----- -- ------- ----- ---- ------- ------ ------- ---------

!      call setup_kwds(ierr)

      open(input, file=fname, status='old', form='formatted', iostat=ios)
      if (ios /= 0) then
         call report_opening_error(fname(1:lstr), mynode, ierr)
         return
      end if



      do while (.not. eof)
         call extract_keyword(input, keyword, kwlen, eof, ierr)
         if (eof) exit
         if (kwlen == 0) cycle  ! no keyword on this line → read next
         if (keyword(1:kwlen) == end_signal) exit
         idx = lookup_keyword(keyword)
         if (idx==0) then
            mpi_master_only write(*,
     &           '("WARNING: unregistered keyword encountered: ",A)') trim(keyword)
            cycle
         end if
         if (associated(registry(idx)%handler)) then
            call registry(idx)%handler(input, ierr)
         else
            write(*,*) "ERROR: No handler registered for keyword ", trim(keyword)
            ierr = ierr + 1
            return
         end if
      end do
      close (input)

      if (ierr /= 0) then
        write(*,'(/1x,2A,I3,1x,A/)') '### ERROR: read_inp :: ',
     &  'A total of', ierr, 'configuration errors discovered.'
       return
      endif
!     call check_srcs
#ifdef MPI
      call MPI_Barrier (ocean_grid_comm, ierr)
#endif
      end subroutine read_inp

      subroutine read_title(unit, ierr)
         integer, intent(in) :: unit
         integer, intent(inout) :: ierr
         integer ios

         read(unit,'(A)',iostat=ios) title
         if (ios /= 0) then
            call report_read_error("title", ierr)
            return
         end if
         mpi_master_only write(*,'(/1x,A)') trim(title)
      end subroutine

      subroutine read_time_stepping(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in) :: unit
      integer, intent(inout) :: ierr

      integer :: ios
      integer :: lstr

! Read ntimes, dt, ndtfast, ninfo
      read(unit, *, iostat=ios) ntimes, dt, ndtfast, ninfo
      if (ios /= 0) then
         call report_read_error("time_stepping", ierr)
         return
      end if

      mpi_master_only write(*,
     &  '(5x,A,I10,3x,A/9x,A,F11.4,2x,A/4x,A,I10,3x,A/6x,A,I10,3x,2A)'
     &    ) 'ntimes =',  ntimes, 'total number of 3D timesteps',
     &          'dt =',     dt,  'time step [sec] for 3D equations',
     &     'ndtfast =', ndtfast, 'mode-splitting ratio',
     &       'ninfo =',   ninfo, 'number of steps between runtime ',
     &                                              'diagnostics'

          dtfast=dt/dble(ndtfast)     ! set barotropic time step.

#ifndef SOLVE3D
      dt     = dtfast
      ntimes = ntimes * ndtfast
      ninfo  = ninfo  * ndtfast
#endif

      end subroutine read_time_stepping

#ifdef MARBL
      subroutine read_marbl_bgc(unit, ierr)
      use marbl_driver, only: marbl_namelist_fname, marbl_tracer_list_fname
#ifdef MARBL_DIAGS
      use marbl_driver, only: marbl_diag_list_fname
#endif
      use mpi
      implicit none

      integer, intent(in) :: unit
      integer, intent(inout) :: ierr
      integer :: ios, lstr

! ---------------------------------------------------------
! Read MARBL namelist file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_namelist_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry", ierr)
         return
      end if

      lstr = len_trim(marbl_namelist_fname)
      mpi_master_only write(*,'(1x,A,15x,A)'),
     &     'MARBL namelist file',marbl_namelist_fname(1:lstr)

! ---------------------------------------------------------
! Read tracer list file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_tracer_list_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry", ierr)
         return
      end if

      lstr = len_trim(marbl_tracer_list_fname)
      mpi_master_only write(*,'(1x,A,5x,A)'),
     &     'MARBL tracer output list file',marbl_tracer_list_fname(1:lstr)

#ifdef MARBL_DIAGS
! ---------------------------------------------------------
! Read diagnostics list file
! ---------------------------------------------------------
      read(unit,'(A)',iostat=ios) marbl_diag_list_fname
      if (ios /= 0) then
         call report_read_error("MARBL_biogeochemistry", ierr)
         return
      end if

      lstr = len_trim(marbl_diag_list_fname)
      mpi_master_only write(*,'(1x,A,1x,A)'),
     &     'MARBL diagnostic output list file',marbl_diag_list_fname(1:lstr)
#endif

      end subroutine read_marbl_bgc
#endif

#ifdef SOLVE3D
      subroutine read_scoord(unit, ierr)
!     Vertical S-coordinates transformation. Note that "hc" may be chosen
!     to be very large (infinity) if vertically uniform sigma is desired.
      use scoord                ! for theta_s, theta_b, hc
      use mpi
      implicit none

      integer, intent(in) :: unit
      integer, intent(inout) :: ierr
      integer :: ios

! Read three S-coordinate parameters
      read(unit, *, iostat=ios) theta_s, theta_b, hc
      if (ios /= 0) then
         call report_read_error("S-coord", ierr)
         return
      end if

          mpi_master_only write(*,'(2(/4x,A,F10.7,2x,A))')
     &    'theta_s =', theta_s, 'vertical S-coordinate surface',
     &    'theta_b =', theta_b, 'and bottom stretching parameters'
          if (hc < 1000.) then
            mpi_master_only write(*,'(9x,A,F10.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          else
            mpi_master_only write(*,'(9x,A,ES14.5,2x,2A)')
     &                   'hc =', hc, 'critical depth [m]'
          endif

      end subroutine read_scoord

      subroutine read_rho0(unit, ierr)
      !--> Boussinesq  reference density.
      use eos_vars              ! for rho0
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

! Read rho0 (Boussinesq reference density)
      read(unit, *, iostat=ios) rho0
      if (ios /= 0) then
         call report_read_error("rho0", ierr)
         return
      end if

      mpi_master_only write(*,'(7x,A,F10.4,2x,A)')  'rho0 =',
     &     rho0, 'Boussinesq reference density [kg/m^3].'

      end subroutine read_rho0
# ifndef NONLIN_EOS
      subroutine read_lin_rho_eos(unit, ierr)
      use eos_vars
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) Tcoef, T0
#  ifdef SALINITY
     &                       , Scoef, S0
#  endif
      if (ios /= 0) then
         call report_read_error('lin_rho_eos', ierr)
         return
      end if

      mpi_master_only write(*,'(4(6x,A,F10.4,2x,A/))')
     &      'Tcoef =', Tcoef,  'thermal expansion [kg/m^3/deg C]'
     &    , '   T0 =',    T0,  'reference temperature [deg C]'
#  ifdef SALINITY
     &    , 'Scoef =', Scoef,  'saline contraction [kg/m^3/PSU]'
     &    , '   S0 =',    S0,  'reference salinity [PSU]'
#  endif

      end subroutine read_lin_rho_eos
# endif

#endif /*SOLVE3D*/
#ifdef UV_VIS2
      subroutine read_lateral_visc(unit, ierr)
!     Lateral viscosity coefficients.
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) visc2
      if (ios /= 0) then
         call report_read_error('lateral_visc', ierr)
         return
      end if

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'visc2 =', visc2,
     &    'horizontal Laplacian kinematic viscosity [m^2/s]'

      end subroutine read_lateral_visc

#if !defined EW_PERIODIC || !defined NS_PERIODIC
      subroutine read_gamma2(unit, ierr)
!     Lateral boundary slipperness.
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) gamma2
      if (ios /= 0) then
         call report_read_error('gamma2', ierr)
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A)')
     &    'gamma2 =', gamma2,
     &    'slipperiness parameter: ',
     &    'free-slip = +1, or no-slip = -1.'

      end subroutine read_gamma2
#endif
#endif

#if defined SOLVE3D && defined TS_DIF2
      subroutine read_tracer_diff2(unit, ierr)
      use param
      use scalars
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios, itrc

      read(unit,*,iostat=ios) (tnu2(itrc), itrc=1,NT)
      if (ios /= 0) then
         call report_read_error('tracer_diff2', ierr)
         return
      end if

      do itrc = 1, NT
         if (itrc == itemp) then
            mpi_master_only write(*,
     & '(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &    'tnu2(',itrc,') =', tnu2(itrc),
     &    'horizontal Laplacian ',
     &    'kinematic heat conductivity [m^2/s]'
         else
            mpi_master_only write(*,
     & '(3x,A,I2,A,ES10.3,2x,2A,I2,A)')
     &    'tnu2(',itrc,') =', tnu2(itrc),
     &    'horizontal Laplacian ',
     &    'diffusion for tracer ', itrc, ', [m^2/s]'
         end if
      end do

      end subroutine read_tracer_diff2
#endif

      subroutine read_bottom_drag(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

#ifdef SOLVE3D
      read(unit,*,iostat=ios) rdrg, rdrg2, Zob
#else
      read(unit,*,iostat=ios) rdrg, rdrg2
#endif

      if (ios /= 0) then
         call report_read_error('bottom_drag', ierr)
         return
      end if

      mpi_master_only write(*,'(7x,A,ES10.3,2x,A)')
     &    'rdrg =', rdrg,
     &    'linear bottom drag coefficient [m/s]'

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'rdrg2 =', rdrg2,
     &    'quadratic bottom drag coefficient, nondim'

#ifdef SOLVE3D
      mpi_master_only write(*,'(8x,A,ES10.3,2x,A)')
     &    'Zob =', Zob,
     &    'bottom roughness height [m]'
#endif

      end subroutine read_bottom_drag

#ifdef SOLVE3D
# if !defined LMD_MIXING && !defined BVF_MIXING && !defined PP_MIXING \
      &&                        !defined MY2_MIXING && !defined MY25_MIXING

      subroutine read_vertical_mixing(unit, ierr)
! Background vertical viscosity and mixing coefficients for tracers.
      use param
      use scalars
      use basic_output       ! for vname
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios, itrc, lstr, lenstr

      read(unit,*,iostat=ios) Akv_bak, (Akt_bak(itrc), itrc=1,NT)
      if (ios /= 0) then
         call report_read_error('vertical_mixing', ierr)
         return
      end if

      mpi_master_only write(*,'(4x,A,ES10.3,2x,A)')
     &    'Akv_bak =', Akv_bak,
     &    'background vertical viscosity [m^2/s]'

      do itrc = 1, NT
         lstr = lenstr(vname(2,indxT+itrc-1))
         mpi_master_only write(*,'(1x,A,I1,A,ES10.3,2x,2A)')
     &       'Akt_bak(', itrc, ') =', Akt_bak(itrc),
     &       'background vertical mixing [m^2/s] for ',
     &       vname(2,indxT+itrc-1)(1:lstr)
      end do

      end subroutine read_vertical_mixing
# endif

# ifdef MY25_MIXING
      subroutine read_MY_bak_mixing(unit, ierr)
!     Mellor-Yamada Level 2.5 turbulent closure parameters.
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) Akq_bak
#  ifdef Q_DIF2
     &                       , q2nu2
#  endif
#  ifdef Q_DIF4
     &                       , q2nu4
#  endif
      if (ios /= 0) then
         call report_read_error('MY_bak_mixing', ierr)
         return
      end if

      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'Akq_bak =', Akq_bak,
     &    'Background vertical mixing for TKE, [m^2/s]'

#  ifdef Q_DIF2
      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'q2nu2 =', q2nu2,
     &    'Horizontal Laplacian mixing for TKE, [m^2/s]'
#  endif

#  ifdef Q_DIF4
      mpi_master_only write(*,'(1x,A,ES10.3,1x,A)')
     &    'q2nu4 =', q2nu4,
     &    'Horizontal biharmonic mixing for TKE, [m^4/s]'
#  endif

      end subroutine read_MY_bak_mixing
#endif

#if defined SFLX_CORR && defined SALINITY
      subroutine read_SSS_correction(unit, ierr)
      use param
      use scalars
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) dSSSdt
      if (ios /= 0) then
         call report_read_error('SSS_correction', ierr)
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSSdt =', dSSSdt,
     &   'Sea-Surface Salinity correction ',
     &   'coefficient expressed',
     &   'kinematically as "piston velocity" [cm/day]'

      dSSSdt = dSSSdt / (100*day2sec)

      end subroutine read_SSS_correction
#endif

# ifdef QCORRECTION
      subroutine read_SST_correction(unit, ierr)
      use param
      use scalars
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) dSSTdt
      if (ios /= 0) then
         call report_read_error('SST_correction', ierr)
         return
      end if

      mpi_master_only write(*,'(5x,A,ES10.3,2x,2A/38x,A)')
     &   'dSSTdt =', dSSTdt,
     &   'Sea-Surface Temperature correction ',
     &   'coefficient expressed',
     &   'kinematically as "piston velocity" [cm/day]'

      dSSTdt = dSSTdt / (100*day2sec)

      end subroutine read_SST_correction
# endif
#endif /*SOLVE3D*/

#if  defined T_FRC_BRY || defined M2_FRC_BRY || defined TNUDGING \
  || defined Z_FRC_BRY || defined M3_FRC_BRY || defined M2NUDGING \
  || defined M3NUDGING  || defined WKB_FRC_BRY
      subroutine read_ubind(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) ubind
      if (ios /= 0) then
         call report_read_error('ubind', ierr)
         return
      end if

      mpi_master_only write(*,'(6x,A,ES10.3,2x,A)')
     &    'ubind =', ubind,
     &    'open boundary binding velcity [m/s]'

      end subroutine read_ubind
#endif

#ifdef SPONGE
      subroutine read_v_sponge(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,*,iostat=ios) v_sponge
      if (ios /= 0) then
         call report_read_error('v_sponge', ierr)
         return
      end if

      mpi_master_only write(*,'(3x,A,F10.2,2x,A)')
     &      'v_sponge =', v_sponge,
     &      'maximum viscosity in sponge layer [m^2/s]'

      end subroutine read_v_sponge
#endif

#ifndef ANA_GRID
      subroutine read_grid(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios, testunit, lstr, lenstr
      character(len=256) :: fname

      read(unit,'(A)',iostat=ios) fname
      if (ios /= 0) then
         call report_read_error('grid', ierr)
         return
      end if

      lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
      call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif

      open(newunit=testunit, file=fname(1:lstr), status='old',
     &     iostat=ios)
      close(testunit)
      if (ios /= 0) then
         call report_opening_error(fname(1:lstr), mynode, ierr)
         return
      end if

      grdname = fname(1:lstr)
      mpi_master_only write(*,'(1x,2A)')
     &      'grid file: ', grdname(1:lstr)

      end subroutine read_grid
#endif /* !ANA_GRID */

      subroutine read_initial(unit, ierr)
!     Initial conditions file name. Check its availability (in the case
!     of analytical initial conditions and nrrec=0 initial conditions are
!     created internally and no file is needed).
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios, lstr, testunit, lenstr
      character(len=256) :: fname

      read(unit,*,iostat=ios) nrrec
      if (ios /= 0) then
         call report_read_error('initial', ierr)
         return
      end if

#ifdef ANA_INITIAL
      if (nrrec > 0) then
#endif
         read(unit,'(A)',iostat=ios) fname
         if (ios /= 0) then
            call report_read_error('initial', ierr)
            return
         end if

         lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
         call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif
         open(newunit=testunit, file=fname(1:lstr), status='old',
     &        iostat=ios)
         close(testunit)
         if (ios /= 0) then
            call report_opening_error(fname(1:lstr), mynode, ierr)
            return
         end if
         ininame = fname(1:lstr)
         mpi_master_only write(*,'(1x,A,I3,2x,3A)')
     &        'initial condition :: rec =', nrrec,
     &        'file = ''', ininame(1:lstr), ''''

#ifdef ANA_INITIAL
      endif
#endif

      end subroutine read_initial

      subroutine read_forcing(unit, ierr)
      use param
      use mpi
      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr

      integer :: ios, lstr, testunit, lenstr
      character(len=256) :: fname

!  Reset forcing storage.

      force_files = ''
      force_info  = ''
      max_frc     = 0
      lstr        = 1

!  Read filenames until a blank line or max_frc_files reached.
      do while (lstr > 0 .and. max_frc < max_frc_files+1)

         read(unit,'(A)',iostat=ios) fname
         if (ios /= 0) then
            call report_read_error('forcing', ierr)
            return
         end if

         lstr = lenstr(fname)

         if (lstr > 0) then

# if defined MPI && defined PARALLEL_FILES
            call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif

! Test file availability

            open(newunit=testunit, file=fname(1:lstr), status='old',
     &           iostat=ios)
            close(testunit)
            if (ios /= 0) then
               call report_opening_error(fname(1:lstr), mynode, ierr)
               return
            end if

! Store file if within limit of allowed no. of forcing files

            if (max_frc < max_frc_files) then

               max_frc = max_frc + 1
               frcfile(max_frc) = fname(1:lstr)

! Write file info to output stream
# ifdef MPI_SILENT_MODE
                if (mynode == 0) then
# endif
                  if (max_frc == 1) then
                    write(*,'(1x,2A)') 'forcing data file(s): ',
     &                                 frcfile(max_frc)(1:lstr)
                  else
                    write(*,'(23x,A)') frcfile(max_frc)(1:lstr)
                  endif
! Add to attributes
                  if (mynode == 0) then
                     call store_string_att(force_files,
     &                                      frcfile(max_frc)(1:lstr))
                  end if

# ifdef MPI_SILENT_MODE
               end if
# endif
            else
                mpi_master_only write(*,'(1x,2A/12x,2A/)')
     &          '### ERROR: read_inp :: Too many forcing files are ',
     &          'specified in input script.',  'Increase parameter ',
     &           '''max_frc_files'' in roms_read_write and recompile.'
                ierr=ierr+1
            end if
         end if   ! lstr > 0
      end do      ! filename loop

      end subroutine read_forcing

#if defined SOLVE3D &&( defined TCLIMATOLOGY ||( defined TNUDGING && \
    defined T_FRC_BRY )) &&   !defined ANA_TCLIMA

      subroutine read_climatology(unit, ierr)
! Climatology file name. Climatology data is needed for (1) to supply
! boundary data for T,S,u,v at open boundaries (just one row of points)
! and (2) nudging to T,S data inside the domain within the  nudging
! finite-width band near the boundary [although depreciated,  this
! practice  remains in some applications; doing so for u,v is no
! longer supported by this code].  Aternatively to (1), the boundary
! data may also be supplied via BRY mechanism, where file contains
! perimeter data only.  In this case (activated by T_FRC_BRY), no
! climatology file is needed.  The following code segments also
! checks for availability of clm_file.

      use param
      use mpi

      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios, lstr, testunit, lenstr
      character(len=256) :: fname

      read(unit,'(A)',iostat=ios) fname
      if (ios /= 0) then
         call report_read_error('climatology', ierr)
         return
      end if

      lstr = lenstr(fname)

# if defined MPI && defined PARALLEL_FILES
      call insert_node(fname, lstr, mynode, NNODES, ierr)
# endif

      open(newunit=testunit, file=fname(1:lstr), status='old',
     &     iostat=ios)
      close(testunit)
      if (ios /= 0) then
         call report_open_error(fname(1:lstr), mynode, ierr)
         return
      end if
      clm_file = fname(1:lstr)
          mpi_master_only write(*,'(1x,4A)')   'climatology data :: ',
     &                           'file = ''', clm_file(1:lstr), ''''

      end subroutine read_climatology
#endif

      subroutine read_output_root_name(unit, ierr)
      ! read from .in file the root-name
      ! for all output netcdf result files
      ! this is called from read_inp.F
      ! The following needs to be in the roms.in input file to use this
      ! subroutine (file name needs to be 5 spaces from left margin):
      !output_root_name:
      !     rootname (<- insert desired rootname)

      implicit none

      integer, intent(in)    :: unit
      integer, intent(inout) :: ierr
      integer :: ios

      read(unit,'(A)',iostat=ios) output_root_name
      if (ios /= 0) then
         call report_read_error('output_root_name', ierr)
         return
      end if

      end subroutine read_output_root_name

      subroutine initial_keyword_check(fname, ierr)
      use keyword_registry
      implicit none

      character(len=*), intent(in) :: fname
      integer, intent(inout) :: ierr

      integer :: unit, ios, kwlen, idx
      character(len=256) :: keyword
      logical :: eof

      open(newunit=unit, file=fname, status='old', action='read', iostat=ios)
      if (ios /= 0) then
         mpi_master_only write(*,*)
     &        "ERROR opening file in first_pass_check:", trim(fname)
         ierr = ierr + 1
         return
      end if

      eof = .false.
      do while(.not.eof)
         call extract_keyword(unit, keyword, kwlen, eof, ierr)
         if (eof) exit
         if (kwlen == 0) cycle
         if (keyword == "end") exit

         idx = lookup_keyword(keyword)
         if (idx > 0) then
            registry(idx)%found = registry(idx)%found + 1
         else
            mpi_master_only write(*,
     &           '("WARNING: unregistered keyword encountered: ",A)') trim(keyword)
         end if
      end do

      close(unit)
      end subroutine initial_keyword_check

      subroutine report_opening_error(fname, mynode, ierr)
      implicit none
      character(len=*), intent(in) :: fname
      integer,          intent(in) :: mynode
      integer,          intent(inout) :: ierr
      character(len=:), allocatable :: msg

      msg = "### ERROR: read_inp :: Cannot find input file '" // trim(fname) // "'"

      write(*,'(/i4,1x,A/)') mynode, msg

      ierr = ierr + 1
      end subroutine report_opening_error

      subroutine report_read_error(keyword, ierr)
      implicit none
      character(len=*), intent(in) :: keyword
      integer,          intent(inout) :: ierr
      character(len=:), allocatable :: msg

      msg = "### ERROR: read_inp :: Cannot read entry '" // trim(keyword) // "'"

      write(*,'(/A/)') msg

      ierr = ierr + 1
      end subroutine report_read_error

      subroutine extract_keyword(unit, keyword, kwlen, eof, ierr)
         implicit none
         integer, intent(in) :: unit
         character(len=*), intent(out) :: keyword
         integer, intent(out) :: kwlen
         logical, intent(out) :: eof
         integer, intent(inout) :: ierr

         character(len=256) :: line
         integer :: ios, start, colon_pos, lenline
         character(len=:), allocatable :: tmp

         eof = .false.
         keyword = ''
         kwlen = 0

         ! read next non-comment line
         do
            read(unit,'(A)',iostat=ios) line
            if (ios < 0) then
               eof = .true.
               return
            else if (ios /= 0) then
               ierr = ierr + 1
               return
            end if
            if (trim(line) /= '' .and. line(1:1) /= '!') exit
         end do

         lenline = len_trim(line)
         if (lenline == 0) return

         start = 1
         do while (start <= lenline .and. line(start:start) == ' ')
            start = start + 1
         end do
         if (start > lenline) return

         colon_pos = index(line(start:lenline), ':')
         if (colon_pos == 0) return
         colon_pos = colon_pos + start - 1

         tmp = adjustl(line(start:colon_pos-1))
         keyword = tmp
         kwlen   = len_trim(tmp)

      end subroutine extract_keyword

!***********************************************************************
!     >  Print SLURM or PBS job ID information (master-only write).
!     >
!     >  Retrieves and prints the job ID and, if applicable, the array task
!     >  index for SLURM or PBS/Torque jobs. Output uses `mpi_master_only write`.
!***********************************************************************
      subroutine print_jobid()

      use param

      implicit none

      character(len=100) :: jobid, taskid
      integer            :: len1, len2, stat1, stat2

! --- SLURM ---
      call get_environment_variable('SLURM_JOB_ID', jobid, len1, stat1)
      call get_environment_variable('SLURM_ARRAY_TASK_ID', taskid, len2, stat2)

      if (stat1 == 0) then
         mpi_master_only write(*,'(A,1X,A)') 'SLURM Job ID:',        trim(jobid(1:len1))
         if (stat2 == 0) then
            mpi_master_only write(*,'(A,1X,A)') 'SLURM Array Task ID:', trim(taskid(1:len2))
         end if
         return
      end if
! --- PBS ---
      call get_environment_variable('PBS_JOBID', jobid, len1, stat1)
      call get_environment_variable('PBS_ARRAY_INDEX', taskid, len2, stat2)

      if (stat1 == 0) then
         mpi_master_only write(*,'(A,1X,A)') 'PBS Job ID:',          trim(jobid(1:len1))
          if (stat2 == 0) then
             mpi_master_only write(*,'(A,1X,A)') 'PBS Array Index:',  trim(taskid(1:len2))
          end if
          return
      end if
         mpi_master_only write(*,'(A)') 'No SLURM or PBS job ID found.'
      end subroutine print_jobid

      end module read_inp_mod
